#!/usr/bin/env python3

PORTMASTER_VERSION = '8.2.1a'

import contextlib
import datetime
import functools
import gettext
import hashlib
import json
import os
import re
import shutil
import sys
import textwrap
import zipfile

from pathlib import Path

################################################################################
## This speeds up harbourmaster from 4-5 seconds to 1-2 seconds.
##
## Insert our extra modules.
PYLIB_ZIP     = Path(__file__).parent / 'pylibs.zip'
PYLIB_ZIP_MD5 = Path(__file__).parent / 'pylibs.zip.md5'
PYLIB_PATH    = Path(__file__).parent / 'pylibs'

if (Path(__file__).parent / 'exlibs').is_dir():
    EXLIB_PATH = Path(__file__).parent / 'exlibs'
    sys.path.insert(0, str(EXLIB_PATH))
    sys.path.insert(0, str(PYLIB_PATH))

else:
    EXLIB_PATH = None

    if PYLIB_ZIP.is_file():
        if PYLIB_PATH.is_dir():
            print("- removing old pylibs.")
            shutil.rmtree(PYLIB_PATH)

        PYLIB_PATH.mkdir(0o755)
        print("- extracting new pylibs.")
        with zipfile.ZipFile(PYLIB_ZIP, 'r') as zf:
            zf.extractall(PYLIB_PATH)

        md5_check = hashlib.md5()
        with PYLIB_ZIP.open('rb') as fh:
            while True:
                data = fh.read(1024 * 1024)
                if len(data) == 0:
                    break

                md5_check.update(data)

        with PYLIB_ZIP_MD5.open('wt') as fh:
            fh.write(md5_check.hexdigest())

        print("- recorded pylibs.zip.md5")

        del md5_check

        print("- removing pylibs.zip")
        PYLIB_ZIP.unlink()

    sys.path.insert(0, str(PYLIB_PATH))

################################################################################
## Now load the stuff we include
import utility
import harbourmaster
import requests

import sdl2
import sdl2.ext

import pySDL2gui

from utility import cprint, do_cprint_output
from loguru import logger

from harbourmaster import (
    HarbourMaster,
    make_temp_directory,
    )


################################################################################
## Logging
LOG_FILE = harbourmaster.HM_TOOLS_DIR / "PortMaster" / "pugwash.txt"
if LOG_FILE.parent.is_dir():
    LOG_FILE_HANDLE = logger.add(LOG_FILE, level="DEBUG", backtrace=True, diagnose=True)


################################################################################
## Translations
LANG_DIR = PYLIB_PATH / "locales"
DEFAULT_LANG = None

def lang_opts(lang):
    yield lang

    if '.' in lang:
        yield lang.rsplit('.')[0]

    if '_' in lang and '.' in lang:
        yield (lang.rsplit('_', 1)[0] + lang.rsplit('.')[1])

    if '_' in lang:
        yield lang.rsplit('_', 1)[0]


def check_lang(lang):
    if lang is None:
        return None

    for lang_opt in lang_opts(lang):
        temp = LANG_DIR / lang_opt / "LC_MESSAGES"
        if temp.is_dir():
            return lang_opt

    return None


def load_lang():
    config = harbourmaster.HM_TOOLS_DIR / "PortMaster" / "config" / "config.json"
    if config.is_file():
        with open(config, 'r') as fh:
            config = json.load(fh)

        config_lang = config.get("language", None)

    else:
        config_lang = None

    environ_lang = os.environ.get('LANG')
    DEFAULT_LANG = environ_lang

    if config_lang and check_lang(config_lang):
        os.environ['LANG'] = check_lang(config_lang)

    elif config_lang and check_lang(environ_lang):
        os.environ['LANG'] = check_lang(environ_lang)

    else:
        os.environ['LANG'] = 'en_US'


def lang_list():
    common_languages = {
        # Sorted by language code
        "de_DE": _("German"),
        "en_US": _("English"),
        "es_ES": _("Spanish"),
        "fr_FR": _("French"),
        "it_IT": _("Italian"),
        # Add more language codes and translations here
        }

    languages = {
        lang_id: lang_name
        for lang_id, lang_name in sorted(common_languages.items(), key=lambda item: (item[1]))
        if (LANG_DIR / lang_id).is_dir()}

    return languages


load_lang()
gettext.bindtextdomain('messages', str(LANG_DIR))
gettext.textdomain('messages')
_ = gettext.gettext

################################################################################
## Code starts here.
"""
-- General State Machine --

Main:
  -> Install Menu
  -> Uninstall Menu -> Port List [Installed filter]
  -> Options
  -> Quit

Install Menu:
  -> All Ports    -> Port List [No filter]
  -> Ready To Run -> Port List [RTR filter]
  -> Genres       -> Port List [Genres filters]
  -> Back

Port List:
  -> List of Ports
    -> Inspect
    -> Back

Options:
  -> TBD.
  -> Back

Inspect:
  -> Install/Re-Install or Uninstall
  -> Back

Install/Uninstall:
  -> Message Screen
  -> Back


Current Template Tags:

    port_info.title
    port_info.description
    port_info.instructions
    port_info.genres
    port_info.porter
    port_info.ready_to_run
    port_info.download_size
    port_info.runtime
    port_info.runtime_status

    system.time_24hr
    system.time_12hr
    system.free_space
    system.used_space
    system.cfw_name
    system.cfw_version
    system.device_name
    system.battery_level
    system.ip_address

"""

__IP_ADDRESS=None
def get_ip_address():
    global __IP_ADDRESS

    if __IP_ADDRESS is not None:
        return __IP_ADDRESS

    import socket

    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.settimeout(0)
    try:
        # doesn't even have to be reachable
        s.connect(('1.1.1.1', 1))
        __IP_ADDRESS = s.getsockname()[0]

    except Exception:
        __IP_ADDRESS = _("Unknown IP")

    finally:
        s.close()

    return __IP_ADDRESS


def format_progress(amount, total, fmt=None):
    if fmt == 'data':
        if total is None:
            return f"{harbourmaster.nice_size(amount)}"

        else:
            return f"{harbourmaster.nice_size(amount)} / {harbourmaster.nice_size(total)}"

    elif fmt == '%':
        if total is None:
            return f"{min(amount, 100):.0f} %"

        else:
            return f"{min(amount / total * 100, 100):.0f} %"

    else:
        if total is None:
            return f"{amount}"

        else:
            return f"{amount} / {total}"


def extract_requirements(text, strict=False):
    if strict:
        default = None
    else:
        default = []

    if '[' not in text:
        return text, default

    if text.count('[') > 1 or not text.endswith(']'):
        logger.error(f"Bad requirement {text}")
        return text.split('[')[0] + "_bad", default

    text, requirement = text.split('[', 1)
    requirements = map(str.strip, requirement[:-1].split(','))
    return text, list(requirements)


def theme_update(target, source):
    capabilities = harbourmaster.device_info()['capabilities']

    for key, value in source.items():
        key, requirements = extract_requirements(key)
        if requirements is not None:
            if not harbourmaster.match_requirements(capabilities, requirements):
                continue

        if isinstance(value, dict):
            theme_update(target.setdefault(key, {}), value)
        elif isinstance(value, list):
            target[key] = value[:]
        else:
            target[key] = value

    return target


def theme_merge(target, source):
    temp = theme_update({}, target)
    temp = theme_update(temp, source)
    return temp


def theme_apply(gui, section_data, base_data, elements):
    new_data = {}
    capabilities = harbourmaster.device_info()['capabilities']

    for region_name, region_data in section_data.items():
        if region_name == "#base":
            base_data = theme_merge(base_data, region_data)
            continue

        elif region_name.startswith("#element:"):
            element_name = region_name.split(':', 1)[1]
            if ':' in element_name:
                element_name, region_name = element_name.split(':', 1)
            else:
                region_name = element_name

            region_name, requirements = extract_requirements(region_name)
            if not harbourmaster.match_requirements(capabilities, requirements):
                continue

            if element_name not in elements:
                logger.debug(f"Error: Unknown element {element_name}")
                continue

            new_data[region_name] = theme_merge(base_data, theme_merge(elements[element_name], region_data))
            continue

        region_name, requirements = extract_requirements(region_name, strict=True)
        if requirements is not None:
            if not harbourmaster.match_requirements(capabilities, requirements):
                continue

            new_data[region_name] = theme_merge(new_data.get(region_name, base_data), region_data)

        else:
            new_data[region_name] = theme_merge(base_data, region_data)

    return new_data


def theme_load(gui, theme_file, color_scheme=None):
    print(f"Loading theme {theme_file}")

    with open(theme_file, 'r') as fh:
        theme_data = json.load(fh)

    if theme_data is None:
        raise ValueError(f"Unable to load theme {theme_file}")

    capabilities = harbourmaster.device_info()["capabilities"]

    base_data = {}
    elements = {}
    sections = {}

    all_schemes = [
        scheme_name
        for scheme_name in theme_data.get("#schemes", {})
        if not scheme_name.startswith("#")]

    if color_scheme is None:
        color_scheme = theme_data.get("#info", {}).get("default-scheme", None)

    if color_scheme not in all_schemes:
        color_scheme = None

    if color_scheme is None:
        if len(all_schemes) > 0:
            color_scheme = all_schemes[0]

    if color_scheme is not None:
        if color_scheme not in theme_data.get("#schemes", {}):
            print(f"- Unable to find {color_scheme} in the theme_data.")
            return None

        else:
            base_scheme = theme_data["#schemes"].get("#base", {})

            for section_name, section_data in theme_data["#schemes"][color_scheme].items():
                if section_name not in ("#base", "#resources", "#pallet"):
                    continue

                theme_data[section_name] = theme_merge(base_scheme.get(section_name, {}), section_data)

    for section_name, section_data in theme_data.items():
        if section_name.startswith('#'):
            if section_name == "#base":
                print("- loading base_data")
                base_data = section_data

            elif section_name == "#resources":
                print("- loading resources:")
                for resource_name, resource_data in section_data.items():
                    resource_set_name = resource_data.get("name", resource_name)

                    if resource_name.lower().rsplit('.', 1)[-1] in ('jpg', 'png', 'svg'):
                        success = gui.images.load_data(resource_name, resource_data) is None and 'FAIL' or 'OKAY'

                        if resource_set_name != resource_name:
                            print(f"  - loading image {resource_name} as {resource_set_name} - [{success}]")
                        else:
                            print(f"  - loading image {resource_name} - [{success}]")

                    elif resource_name.lower().rsplit('.', 1)[-1] in ('ogg', 'wav', 'mp3', 'mod'):
                        success = gui.sounds.load(resource_name, resource_set_name) is None and 'FAIL' or 'OKAY'

                        if resource_set_name != resource_name:
                            print(f"  - loading sound {resource_name} as {resource_set_name} - [{success}]")
                        else:
                            print(f"  - loading sound {resource_name} - [{success}]")

            elif section_name == "#elements":
                print("- loading elements:")
                for element_name, element_data in section_data.items():
                    element_name, requirements = extract_requirements(element_name)
                    if not harbourmaster.match_requirements(capabilities, requirements):
                        continue

                    elements[element_name] = element_data

                    last_value = None
                    for element_key, element_value in element_data.items():
                        element_key, requirements = extract_requirements(element_key)
                        if element_key != 'area':
                            continue

                        if not harbourmaster.match_requirements(capabilities, requirements):
                            continue

                        last_value = element_value

                    if last_value is not None:
                        gui.default_rects.make_rect(element_data.get('parent', 'root'), element_name, last_value)

            elif section_name == "#pallet":
                print("- loading pallet:")
                for pallet_name, pallet_value in section_data.items():
                    gui.pallet[pallet_name] = pallet_value

        else:
            section_name, requirements = extract_requirements(section_name, strict=True)
            if requirements is not None:
                if not harbourmaster.match_requirements(capabilities, requirements):
                    logger.debug(f"Not matched: {section_name} -> {capabilities}, {requirements}")
                    continue

                if section_name not in sections:
                    logger.error(f"{section_name} not yet defined, skipping. ({requirement})")
                    continue

                print(f"  - loading section {section_name} ({requirement})")
                sections[section_name] = theme_apply(gui, section_data, sections[section_name], elements)
            else:
                print(f"  - loading section {section_name}")
                sections[section_name] = theme_apply(gui, section_data, base_data, elements)

    if harbourmaster.HM_TESTING:
        with open('debug.json', 'w') as fh:
            json.dump(sections, fh, indent=4)

    return sections


class StringFormatter:
    def __init__(self, data_dict):
        self.data_dict = data_dict

    @functools.lru_cache(1024)
    def parse_text(self, text):
        result = []
        current = ''
        while len(text) > 0:
            before, bracket, text = text.partition('{')
            current += before

            if bracket == '' or text == '':
                break

            elif text.startswith('{'):
                current += '{'
                text = text[1:]
                continue

            else:
                token, bracket, text = text.partition('}')
                if bracket == '':
                    current += token
                    break

                if token == '':
                    current += '{}'
                    continue

                result.append((current, token))
                current = ''

        if current != '':
            result.append((current, None))

        return tuple(result)

    def execute_if(self, text, keys_used=None):
        do_not = False

        if text.startswith('!'):
            do_not = True
            text = text[1:]

        if ':' in text:
            key, value = text.split(':', 1)

            if keys_used is not None and key not in keys_used:
                keys_used.append(key)

            if value.startswith(':'):
                value = value[1:]
                if keys_used is not None and value not in keys_used:
                    keys_used.append(value)

                value = self.data_dict.get(value, '')

            result = self.data_dict.get(key, '') == value
        else:
            if keys_used is not None and text not in keys_used:
                keys_used.append(text)

            result = self.data_dict.get(text, '') not in ('', 'None')

        if do_not:
            result = not result

        return result

    def format_string(self, text, keys_used=None):
        output = []
        stack = [True]

        for before, key in self.parse_text(text):
            if stack[-1] and before != '':
                output.append(before)

            if key is not None:
                if key == 'else':
                    stack[-1] = not stack[-1]

                elif key == 'endif':
                    if len(stack) > 1:
                        stack.pop(-1)

                elif key.startswith('if:'):
                    if_key = key[3:]

                    if self.execute_if(if_key, keys_used):
                        stack.append(True)
                    else:
                        stack.append(False)

                else:
                    if keys_used is not None and key not in keys_used:
                        keys_used.append(key)

                    value = self.data_dict.get(key, f'{{{key}}}')
                    if stack[-1]:
                        output.append(value)

        return ''.join(output)


class BaseScene:
    """
    Scenes handle drawing / logic, different scenes can be transitioned to and or layered.

    Only the top layer receives events.
    """

    def __init__(self, gui):
        self.gui = gui
        self.tags = {}
        self.regions = []
        self.text_regions = {}
        self.bar_regions = {}
        self.update_regions = {}
        self.music = None
        self.music_volume = 128
        self.active = False

    def scene_deactivate(self):
        self.active = False

    def scene_activate(self):
        if not self.active:
            self.active = True
            self.gui.sounds.easy_music(self.music, volume=max(0, min(self.music_volume, 128)))

    def load_regions(self, section, required_tags):
        rects = self.gui.new_rects()
        temp_required_tags = list(required_tags)

        for number, (region_name, region_data) in enumerate(self.gui.theme_data[section].items()):
            if "music" in region_data:
                self.music = region_data["music"]
                self.music_volume = region_data.get("music-volume", 128)

            # print(f"Loading region {region_name}: {region_data}")
            region = pySDL2gui.Region(self.gui, region_data, region_name, number, rects)

            if "text" in region_data and "{" in region_data["text"]:
                text_keys = []
                region.text = self.gui.format_data(region_data["text"], text_keys)

                self.text_regions[region_name] = (region, region_data["text"])
                for key in text_keys:
                    self.update_regions.setdefault(key, []).append(region_name)

            if "bar" in region_data:
                found = False
                text_keys = []
                bar_copy = region_data["bar"][:]
                for i in range(len(region_data["bar"])):
                    bar_item = region_data["bar"][i]
                    if not isinstance(bar_item, str) or "{" not in bar_item:
                        continue

                    found = True
                    region_data["bar"][i] = self.gui.format_data(bar_item, text_keys)

                if found:
                    self.bar_regions[region_name] = (region, bar_copy)
                    for key in text_keys:
                        self.update_regions.setdefault(key, []).append(region_name)

            region_tag = region_data.get("tag", region_name)
            if region_tag is not None:
                self.tags[region_tag] = region

            if region_tag in temp_required_tags:
                temp_required_tags.remove(region_tag)

            self.regions.append(region)

        if len(temp_required_tags) > 0:
            logger.error(f"Error: missing one or more tags for section {section}: {', '.join(temp_required_tags)}")
            raise RuntimeError("Error missing section tag in theme")

        self.regions.sort(key=lambda x: (x.z_index, x.z_position))

    def update_data(self, keys):
        regions = set()

        for key in keys:
            if key in self.update_regions:
                regions.update(self.update_regions[key])

        for region_name in regions:
            if region_name in self.text_regions:
                region, text = self.text_regions[region_name]
                region.text = self.gui.format_data(text)

            elif region_name in self.bar_regions:
                region, bar = self.bar_regions[region_name]
                new_bar = bar[:]

                for i, bar_item in enumerate(bar):                    
                    if not isinstance(bar_item, str) or "{" not in bar_item:
                        continue

                    new_bar[i] = self.gui.format_data(bar_item)

                region.bar = new_bar

    def do_update(self, events):
        for region in self.regions:
            # print(f"DRAW {region}")
            region.update()

        return False

    def do_draw(self):
        for region in self.regions:
            # print(f"DRAW {region}")
            if not region.visible:
                continue

            region.draw()

    def set_buttons(self, key_map):
        key_to_image = {
            'A': '_A',
            'B': '_B',
            'X': '_X',
            'Y': '_Y',
            'UP':    '_UP',
            'DOWN':  '_DOWN',
            'LEFT':  '_LEFT',
            'RIGHT': '_RIGHT',
            'START': '_START',
            'SELECT': '_SELECT',
            'L': '_L',
            'R': '_R',
            }

        if 'button_bar' not in self.tags:
            return

        if len(key_map) == 0:
            self.tags['button_bar'].bar = None
            return

        actions = {}

        for key, action in key_map.items():
            actions.setdefault(action, []).append(key_to_image.get(key, key))

        output = []
        for action, key in actions.items():
            output.extend(key)
            output.append(action)

        print(f"-> {key_map} = {output}")

        self.tags['button_bar'].bar = output

    def button_activate(self):
        if 'button_bar' not in self.tags:
            return

        self.gui.sounds.play(self.tags['button_bar'].button_sound, volume=self.tags['button_bar'].button_sound_volume)


class MainMenuScene(BaseScene):
    def __init__(self, gui):
        super().__init__(gui)

        self.load_regions("main_menu", ['option_list', 'button_bar'])

        self.tags['option_list'].reset_options()
        self.tags['option_list'].add_option(('install', []), _("All Ports"))
        self.tags['option_list'].add_option(('install', ['rtr']), _("Ready to Run Ports"))
        self.tags['option_list'].add_option(('uninstall', ['installed']), _("Uninstall Ports"))
        self.tags['option_list'].add_option(None, "")
        self.tags['option_list'].add_option(('options', None), _("Options"))
        self.tags['option_list'].add_option(('exit', None), _("Exit"))
        self.set_buttons({'A': _('Enter'), 'B': _('Quit')})

    def do_update(self, events):
        super().do_update(events)

        if events.was_pressed('A'):
            selected_option, selected_parameter = self.tags['option_list'].selected_option()

            self.button_activate()

            if selected_option in ('install', 'uninstall'):
                self.gui.push_scene('ports', PortsListScene(self.gui, {'mode': selected_option, 'base_filters': selected_parameter}))
                return True

            elif selected_option == 'options':
                self.gui.push_scene('option', OptionScene(self.gui))
                return True

            elif selected_option == 'exit':
                self.gui.do_cancel()
                return True

        elif events.was_pressed('B'):
            self.button_activate()
            self.gui.do_cancel()
            return True


class OptionScene(BaseScene):
    def __init__(self, gui):
        super().__init__(gui)

        self.load_regions("option_menu", ['option_list', 'button_bar'])

        self.tags['option_list'].reset_options()
        self.tags['option_list'].add_option('update-ports', _("Update Ports"))
        self.tags['option_list'].add_option(None, "")
        self.tags['option_list'].add_option('select-language', _("Choose Language"))
        self.tags['option_list'].add_option(None, "")
        self.tags['option_list'].add_option('select-theme', _("Select Theme"))
        schemes = self.gui.get_theme_schemes_list()
        if len(schemes) > 0:
            self.tags['option_list'].add_option('select-scheme', _("Select Color Scheme"))

        self.tags['option_list'].add_option(None, "")
        self.tags['option_list'].add_option('back', _("Back"))
        self.set_buttons({'A': _('Enter'), 'B': _('Back')})

    def do_update(self, events):
        super().do_update(events)

        if events.was_pressed('A'):
            selected_option = self.tags['option_list'].selected_option()

            self.button_activate()

            print(f"Selected {selected_option}")

            if selected_option == 'update-ports':
                self.gui.do_update_ports()
                return True

            if selected_option == 'keyboard':
                self.gui.push_scene('osk', OnScreenKeyboard(self.gui))
                return True

            elif selected_option == 'select-theme':
                self.gui.push_scene('select-theme', ThemesScene(self.gui))
                return True

            elif selected_option == 'select-scheme':
                self.gui.push_scene('select-scheme', ThemeSchemeScene(self.gui))
                return True

            elif selected_option == 'select-language':
                self.gui.push_scene('select-language', LanguageScene(self.gui))
                return True

            elif selected_option == 'back':
                self.gui.pop_scene()
                return True

        elif events.was_pressed('B'):
            self.button_activate()
            self.gui.pop_scene()
            return True


class ThemesScene(BaseScene):
    def __init__(self, gui):
        super().__init__(gui)

        self.load_regions("option_menu", ['option_list', ])

        themes = self.gui.get_themes_list()
        selected_theme = self.gui.hm.cfg_data['theme']

        self.tags['option_list'].reset_options()
        for theme_name, theme_data in themes.items():
            if theme_name == selected_theme:
                self.tags['option_list'].add_option((None, ''), _("{theme_name} (Selected)").format(theme_name=theme_data['name']))
            else:
                self.tags['option_list'].add_option(('select-theme', theme_name), theme_data['name'])

        self.tags['option_list'].add_option(None, "")
        self.tags['option_list'].add_option(('back', None), _("Back"))
        self.set_buttons({'A': _('Select'), 'B': _('Back')})

    def do_update(self, events):
        super().do_update(events)

        if events.was_pressed('A'):
            selected_option, selected_parameter = self.tags['option_list'].selected_option()

            self.button_activate()

            print(f"Selected {selected_option} -> {selected_parameter}")

            if selected_option == 'back':
                self.gui.pop_scene()
                return True

            elif selected_option == 'select-theme':
                if self.gui.message_box(_("Do you want to change theme?\n\nYou will have to restart for it to take affect."), want_cancel=True):
                    self.gui.hm.cfg_data['theme'] = selected_parameter
                    self.gui.hm.cfg_data['theme-scheme'] = None
                    self.gui.hm.save_config()
                    self.gui.events.running = False

                    if not harbourmaster.HM_TESTING:
                        reboot_file = (harbourmaster.HM_TOOLS_DIR / "PortMaster" / ".pugwash-reboot")
                        if not reboot_file.is_file():
                            reboot_file.touch(0o644)

                    return True

        elif events.was_pressed('B'):
            self.button_activate()
            self.gui.pop_scene()
            return True


class ThemeSchemeScene(BaseScene):
    def __init__(self, gui):
        super().__init__(gui)

        self.load_regions("option_menu", ['option_list', ])

        theme_name = self.gui.get_current_theme()
        schemes = self.gui.get_theme_schemes_list()

        default_scheme = self.gui.get_theme_data(theme_name).get("#info", {}).get("default-scheme", None)
        selected_scheme = self.gui.hm.cfg_data.get('theme-scheme', default_scheme)

        self.tags['option_list'].reset_options()
        for scheme_name in schemes:
            if selected_scheme is None or scheme_name == selected_scheme:
                selected_scheme = scheme_name
                self.tags['option_list'].add_option((None, ''), _("{item_name} (Selected)").format(item_name=scheme_name))
            else:
                self.tags['option_list'].add_option(('select-scheme', scheme_name), scheme_name)

        self.tags['option_list'].add_option(None, "")
        self.tags['option_list'].add_option(('back', None), _("Back"))
        self.set_buttons({'A': _('Select'), 'B': _('Back')})

    def do_update(self, events):
        super().do_update(events)

        if events.was_pressed('A'):
            selected_option, selected_parameter = self.tags['option_list'].selected_option()

            self.button_activate()

            print(f"Selected {selected_option} -> {selected_parameter}")

            if selected_option == 'back':
                self.gui.pop_scene()
                return True

            elif selected_option == 'select-scheme':
                if self.gui.message_box(_("Do you want to change the themes color scheme?\n\nYou will have to restart for it to take affect."), want_cancel=True):
                    self.gui.hm.cfg_data['theme-scheme'] = selected_parameter
                    self.gui.hm.save_config()
                    self.gui.events.running = False

                    if not harbourmaster.HM_TESTING:
                        reboot_file = (harbourmaster.HM_TOOLS_DIR / "PortMaster" / ".pugwash-reboot")
                        if not reboot_file.is_file():
                            reboot_file.touch(0o644)

                    return True

        elif events.was_pressed('B'):
            self.button_activate()
            self.gui.pop_scene()
            return True


class LanguageScene(BaseScene):
    def __init__(self, gui):
        super().__init__(gui)

        self.load_regions("option_menu", ['option_list', ])

        languages = lang_list()
        selected_lang = os.environ['LANG']

        self.tags['option_list'].reset_options()
        for lang_code, lang_name in languages.items():
            if lang_code == selected_lang:
                self.tags['option_list'].add_option((None, ''), _("{lang_name} (Selected)").format(lang_name=lang_name))
            else:
                self.tags['option_list'].add_option(('select-language', lang_code), lang_name)

        self.tags['option_list'].add_option(None, "")
        self.tags['option_list'].add_option(('back', None), _("Back"))
        self.set_buttons({'A': _('Select'), 'B': _('Back')})

    def do_update(self, events):
        super().do_update(events)

        if events.was_pressed('A'):
            selected_option, selected_parameter = self.tags['option_list'].selected_option()

            self.button_activate()

            print(f"Selected {selected_option} -> {selected_parameter}")

            if selected_option == 'back':
                self.gui.pop_scene()
                return True

            elif selected_option == 'select-language':
                if self.gui.message_box(_("Do you want to change language?\n\nYou will have to restart for it to take affect."), want_cancel=True):
                    self.gui.hm.cfg_data['language'] = selected_parameter
                    self.gui.hm.save_config()
                    self.gui.events.running = False

                    if not harbourmaster.HM_TESTING:
                        reboot_file = (harbourmaster.HM_TOOLS_DIR / "PortMaster" / ".pugwash-reboot")
                        if not reboot_file.is_file():
                            reboot_file.touch(0o644)

                    return True

        elif events.was_pressed('B'):
            self.button_activate()
            self.gui.pop_scene()
            return True


class OnScreenKeyboard(BaseScene):
    def __init__(self, gui):
        super().__init__(gui)

        self.load_regions("on_screen_keyboard", ['keyboard'])

        self.mode = 'lower'
        self.build_keyboard()
        self.tags['keyboard'].list_select(2)
        self.tags['keyboard'].bar_select(4, 2)

    def build_keyboard(self, keep=False):
        if keep:
            last_list_select = self.tags['keyboard'].list_selected()
            last_bar_select = self.tags['keyboard'].bar_selected()

        self.tags['keyboard'].reset_options()
        if self.mode == 'lower':
            self.tags['keyboard'].add_option('row-1', [' ` ', ' 1 ', ' 2 ', ' 3 ', ' 4 ', ' 5 ', ' 6 ', ' 7 ', ' 8 ', ' 9 ', ' 0 ', ' - ', ' = '], 0)
            self.tags['keyboard'].add_option('row-2', [' q ', ' w ', ' e ', ' r ', ' t ', ' y ', ' u ','  i ', ' o ', ' p ', ' [ ', ' ] ', ' \\ '], 0)
            self.tags['keyboard'].add_option('row-3', [' a ', ' s ', ' d ', ' f ', ' g ', ' h ', ' j ', ' k ', ' l ', ' ; ', ' \' '], 0)
            self.tags['keyboard'].add_option('row-4', [' z ', ' x ', ' c ', ' v ', ' b ', ' n ', ' m ', ' , ', ' . ', ' / '], 0)
            self.tags['keyboard'].add_option('row-5', [' UPPER ', '    [_____]    ', ' << '], 0)

            self.set_buttons({'A': _('Select'), 'B': _('Delete'), 'X': _('Upper Case'), 'Y': _('Space'), 'START': _('Enter'), 'SELECT': _('Cancel')})
        else:
            self.tags['keyboard'].add_option('row-1', [' ~ ', ' ! ', ' @ ', ' # ', ' $ ', ' % ', ' ^ ', ' & ', ' * ', ' ( ', ' ) ', ' _ ', ' + '], 0)
            self.tags['keyboard'].add_option('row-2', [' Q ', ' W ', ' E ', ' R ', ' T ', ' Y ', ' U ','  I ', ' O ', ' P ', ' { ', ' } ', ' | '], 0)
            self.tags['keyboard'].add_option('row-3', [' A ', ' S ', ' D ', ' F ', ' G ', ' H ', ' J ', ' K ', ' L ', ' : ', ' " '], 0)
            self.tags['keyboard'].add_option('row-4', [' Z ', ' X ', ' C ', ' V ', ' B ', ' N ', ' M ', ' < ', ' > ', ' ? '], 0)
            self.tags['keyboard'].add_option('row-5', [' LOWER ', '    [_____]    ', ' << '], 0)

            self.set_buttons({'A': _('Select'), 'B': _('Delete'), 'X': _('Lower Case'), 'Y': _('Space'), 'START': _('Enter'), 'SELECT': _('Cancel')})

        if keep:
            self.tags['keyboard'].list_select(last_list_select)
            self.tags['keyboard'].bar_select(last_bar_select)

        self.last_select = self.tags['keyboard'].list_selected()

    def do_update(self, events):
        super().do_update(events)

        if self.last_select != self.tags['keyboard'].list_selected():
            item = self.tags['keyboard'].bar_selected(self.last_select)
            self.tags['keyboard'].bar_select(item)
            self.last_select = self.tags['keyboard'].list_selected()

        if events.was_pressed('START') or events.was_pressed('A'):
            selected_option = self.tags['keyboard'].selected_option()
            selected_key = self.tags['keyboard'].bar_selected()

            # print(_("Selected {selected_option}"))

            if selected_option == 'back':
                self.gui.pop_scene()
                return True

            return True

        elif events.was_pressed('B'):
            self.gui.pop_scene()
            return True

        elif events.was_pressed('X'):
            if self.mode == 'upper':
                self.mode = 'lower'
            else:
                self.mode = 'upper'

            self.build_keyboard(keep=True)


class InstallMenuScene(BaseScene):
    def __init__(self, gui):
        super().__init__(gui)


class PortsListScene(BaseScene):
    def __init__(self, gui, options):
        super().__init__(gui)

        self.options = options
        self.options.setdefault('base_filters', [])
        self.options.setdefault('filters', [])

        self.load_regions("ports_list", [
            'ports_list',
            'port_image',
            ])

        self.ready = False
        self.update_ports()

        if self.options['mode'] == 'install':
            self.set_buttons({'A': _('Show Info'), 'B': _('Back'), 'X': _('Filters')})
        else:
            self.set_buttons({'A': _('Show Info'), 'B': _('Back')})

    def update_ports(self):
        if self.gui.hm is None:
            self.all_ports = {}
            self.port_list = []
            self.last_port = 0
            self.tags['ports_list'].selected = 0
            return

        if not self.ready:
            self.gui.set_data('ports_list.total_ports', str(len(self.gui.hm.list_ports(filters=(self.options['base_filters'])))))

        self.all_ports = self.gui.hm.list_ports(filters=(self.options['base_filters'] + self.options['filters']))
        self.port_list = list(self.all_ports.keys())

        self.gui.set_data('ports_list.filters', ', '.join(sorted(self.options['filters'])))
        self.gui.set_data('ports_list.filter_ports', str(len(self.port_list)))

        if len(self.port_list) == 0:
            self.tags['ports_list'].list = [
                _('NO PORTS')]

            self.tags['port_image'].image = self.gui.get_port_image("no-image")
            self.gui.set_port_info(None, {})

            self.gui.set_data("port_info.title", _("** NO PORTS FOUND **"))

            if len(self.options['filters']) == 0:
                self.gui.set_data("port_info.description", _("Download ports first."))
            else:
                self.gui.set_data("port_info.description", _("Try removing some filters."))

        else:
            self.tags['ports_list'].list = [
                self.all_ports[port_name]['attr']['title']
                for port_name in self.port_list]

        if self.tags['ports_list'].selected >= len(self.port_list):
            if len(self.port_list) == 0:
                self.tags['ports_list'].selected = 0
            else:
                self.tags['ports_list'].selected = len(self.port_list) - 1

        self.last_port = self.tags['ports_list'].selected + 1
        self.ready = True

    def try_to_select(self, port_name, port_title):
        ## Try and select a port
        if port_name in self.port_list:
            # We found it
            self.tags['ports_list'].selected = self.port_list.index(port_name)
            self.last_port = self.tags['ports_list'].selected + 1
            return

        ## Okay find a port with a name greater than ours, and then select the one before it.
        for i in range(len(self.port_list)):
            if self.all_ports[self.port_list[i]]['attr']['title'] > port_title:
                self.tags['ports_list'].selected = max(i-1, 0)
                self.last_port = self.tags['ports_list'].selected + 1
                return

        ## Do nothing.

    def selected_port(self):
        if len(self.port_list) == 0:
            return 0

        self.last_port = self.tags['ports_list'].selected
        return self.port_list[self.last_port]

    def do_update(self, events):
        super().do_update(events)
        if not self.ready:
            self.update_ports()
            if not self.ready:
                return True

        if len(self.port_list) > 0 and self.last_port != self.tags['ports_list'].selected:
            self.last_port = self.tags['ports_list'].selected

            port_name = self.port_list[self.last_port]
            port_info = self.all_ports[port_name]

            self.gui.set_port_info(port_name, port_info)

            self.tags['port_image'].image = self.gui.get_port_image(port_name)

        if self.options['mode'] == 'install' and events.was_pressed('X'):
            self.button_activate()

            if len(self.port_list) > 0 or len(self.options['filters']) > 0:
                self.gui.push_scene('ports', FiltersScene(self.gui, self))

            return True

        if events.was_pressed('B'):
            self.button_activate()
            self.gui.pop_scene()
            return True

        if events.was_pressed('A') and len(self.port_list) > 0:
            self.button_activate()
            self.last_port = self.tags['ports_list'].selected
            port_name = self.port_list[self.last_port]

            logger.debug(f"{self.options['mode']}: {port_name}")
            if self.options['mode'] == 'install':
                self.ready = False
                self.gui.push_scene('port_info', PortInfoScene(self.gui, port_name, 'install'))

            elif self.options['mode'] == 'uninstall':
                self.ready = False
                self.gui.push_scene('port_info', PortInfoScene(self.gui, port_name, 'uninstall'))

            return True


class PortInfoScene(BaseScene):
    def __init__(self, gui, port_name, action):
        super().__init__(gui)

        self.load_regions("port_info", ['port_image', 'button_bar'])

        self.port_name = port_name
        self.action = action
        self.ready = False
        self.update_port()

        if self.action == 'install':
            self.set_buttons({'A': _('Install'), 'B': _('Back')})
        else:
            self.set_buttons({'A': _('Uninstall'), 'B': _('Back')})

    def update_port(self):
        if self.gui.hm is None:
            return

        if self.action == 'install':
            self.port_info = self.gui.hm.port_info(self.port_name)

        elif self.port_name in self.gui.hm.installed_ports:
            self.port_info = self.gui.hm.installed_ports[self.port_name]

        elif self.port_name in self.gui.hm.broken_ports:
            self.port_info = self.gui.hm.broken_ports[self.port_name]

        else:
            raise RuntimeError(f"HRMMMMmmmmm {self.port_name}")

        logger.debug(f"{self.action}: {self.port_name} -> {self.port_info}")

        self.tags['port_image'].image = self.gui.get_port_image(self.port_name)
        self.gui.set_port_info(self.port_name, self.port_info)

        self.ready = True

    def do_update(self, events):
        super().do_update(events)

        if events.was_pressed('A'):
            self.button_activate()
            self.gui.pop_scene()

            if self.action == 'install':
                self.gui.do_install(self.port_name)

            elif self.action == 'uninstall':
                self.gui.do_uninstall(self.port_name)

            return True

        if events.was_pressed('B'):
            self.button_activate()
            self.gui.pop_scene()
            return True

        return True


class FiltersScene(BaseScene):
    def __init__(self, gui, list_scene):
        super().__init__(gui)

        self.load_regions("filter_list", [
            'filter_list',
            ])

        self.list_scene = list_scene
        self.locked_genres = list(list_scene.options['base_filters'])
        self.selected_genres = list(list_scene.options['filters'])
        self.selected_port = list_scene.selected_port()

        if len(list_scene.all_ports) > 0:
            self.selected_port_title = list_scene.all_ports[self.selected_port]['attr']['title']
        else:
            ## Christian_Hatian wins again!
            self.selected_port_title = "2048.zip"

        self.port_list = []

        self.ready = False
        self.update_filters()

    def update_filters(self):
        if self.gui.hm is None:
            return

        genres = self.locked_genres + self.selected_genres
        total_ports = len(self.gui.hm.list_ports(genres))

        self.tags['filter_list'].bar_select_mode = 'full'

        first_add = True
        add_blank = False

        selected_option = self.tags['filter_list'].selected_option()
        selected_offset = 0

        self.tags['filter_list'].reset_options()

        for hm_genre in harbourmaster.HM_GENRES:
            if hm_genre in self.locked_genres:
                continue

            if hm_genre in genres:
                ports = total_ports
                text = ["    ", "_CHECKED", f"  {hm_genre}", None, "    ", f"  {ports}"]
            else:
                ports = len(self.gui.hm.list_ports(genres + [hm_genre]))
                text = ["    ", "_UNCHECKED", f"  {hm_genre}", None, "    ", f"  {ports}"]

            if ports == 0:
                continue

            if first_add:
                self.tags['filter_list'].add_option(None, _("Genres:"))
                first_add = False
                add_blank = True

            self.tags['filter_list'].add_option(hm_genre, text)

            if selected_option == hm_genre:
                selected_offset = len(self.tags['filter_list'].options) - 1

        first_add = True

        for hm_genre in ['rtr', 'mono']:   # 'godot'
            if hm_genre in self.locked_genres:
                continue

            if hm_genre in genres:
                ports = total_ports
                text = ["    ", "_CHECKED", f"  {hm_genre}", None, "    ", f"  {ports}"]
            else:
                ports = len(self.gui.hm.list_ports(genres + [hm_genre]))
                text = ["    ", "_UNCHECKED", f"  {hm_genre}", None, "    ", f"  {ports}"]

            if ports == 0:
                continue

            if first_add:
                if add_blank:
                    self.tags['filter_list'].add_option(None, "")
                self.tags['filter_list'].add_option(None, _("Attributes:"))
                first_add = False

            self.tags['filter_list'].add_option(hm_genre, text)

            if selected_option == hm_genre:
                selected_offset = len(self.tags['filter_list'].options) - 1

        first_add = True

        for hm_genre in self.gui.hm.porters_list():
            if hm_genre in self.locked_genres:
                continue

            if hm_genre in genres:
                ports = total_ports
                text = ["    ", "_CHECKED", f"  {hm_genre}", None, "    ", f"  {ports}"]
            else:
                ports = len(self.gui.hm.list_ports(genres + [hm_genre]))
                text = ["    ", "_UNCHECKED", f"  {hm_genre}", None, "    ", f"  {ports}"]

            if ports == 0:
                continue

            if first_add:
                if add_blank:
                    self.tags['filter_list'].add_option(None, "")
                self.tags['filter_list'].add_option(None, _("Porters:"))
                first_add = False

            self.tags['filter_list'].add_option(hm_genre, text)

            if selected_option == hm_genre:
                selected_offset = len(self.tags['filter_list'].options) - 1

        self.tags['filter_list'].list_select(selected_offset, direction=1)

        self.ready = True

    def do_update(self, events):
        super().do_update(events)
        if not self.ready:
            self.update_filters()
            if not self.ready:
                return True

        if events.was_pressed('A'):
            selected_filter = self.tags['filter_list'].options[self.tags['filter_list'].selected]
            if selected_filter is None:
                return True

            if selected_filter in self.selected_genres:
                self.selected_genres.remove(selected_filter)
            else:
                self.selected_genres.append(selected_filter)

            self.update_filters()
            self.list_scene.options['filters'] = self.selected_genres
            self.list_scene.update_ports()
            self.list_scene.try_to_select(self.selected_port, self.selected_port_title)
            return True

        if events.was_pressed('B') or events.was_pressed('X'):
            self.gui.pop_scene()
            return True

        return True


class MessageWindowScene(BaseScene):
    """
    This is a scrolling window showing messages for downloading/installing/uninstalling/updating.

    It can have an optional progress bar at the bottom.
    """
    def __init__(self, gui):
        super().__init__(gui)

        self.load_regions("message_window", [
            'message_text',
            'progress_bar',
            'button_bar',
            ])

        self.cancellable = not self.gui.cancellable
        self.update_buttons()

    def update_buttons(self):
        if self.cancellable == self.gui.cancellable:
            return

        self.cancellable = self.gui.cancellable

        if self.cancellable:
            self.set_buttons({'B': _('Cancel')})
        else:
            self.set_buttons({})

    def do_update(self, events):
        super().do_update(events)
        # sdl2.SDL_Delay(1000)

        self.update_buttons()

        if self.gui.callback_amount is not None:
            self.tags['progress_bar'].progress_amount = self.gui.callback_amount
        else:
            self.tags['progress_bar'].progress_amount = 0

        if events.was_pressed('B'):
            if self.gui.cancellable:
                if self.gui.message_box(
                        _('Are you sure you want to cancel?'),
                        want_cancel=True):
                    self.gui.do_cancel()


class MessageBoxScene(BaseScene):
    def __init__(self, gui, message, *, want_cancel=False, ok_text=None, cancel_text=None):
        super().__init__(gui)

        if ok_text is None:
            ok_text = _("Okay")

        if cancel_text is None:
            cancel_text = _("Cancel")

        self.load_regions("message_box", ['message_text', ])

        self.tags['message_text'].text = message

        buttons = {}
        if want_cancel:
            self.set_buttons({'A': ok_text, 'B': cancel_text})

        else:
            self.set_buttons({'A': ok_text})


class PortMasterGUI(pySDL2gui.GUI, harbourmaster.Callback):
    TICK_INTERVAL = 1000 // 5
    TEXT_DATA_FREQ = 5000
    MIN_THEME_VERSION = 1

    def __init__(self):
        # Initialize SDL
        sdl2.ext.init(
            joystick=True)

        def nice_version(v):
            return f"{v.major}.{v.minor}.{v.patch}"

        version = sdl2.SDL_version()
        sdl2.SDL_GetVersion(version)

        logger.debug(f"SDL VERSION: {nice_version(version)}")
        logger.debug(f"TTF VERSION: {nice_version(sdl2.sdlttf.TTF_Linked_Version()[0])}")
        logger.debug(f"IMG VERSION: {nice_version(sdl2.sdlimage.IMG_Linked_Version()[0])}")
        logger.debug(f"MIX VERSION: {nice_version(sdl2.sdlmixer.Mix_Linked_Version()[0])}")

        # Define window dimensions
        self.display_width = 640
        self.display_height = 480
        self.hm = None

        # Get the current display mode
        display_mode = sdl2.video.SDL_DisplayMode()
        capabilities = harbourmaster.device_info()

        if sdl2.video.SDL_GetCurrentDisplayMode(0, display_mode) != 0:
            print("Failed to get display mode:", sdl2.SDL_GetError())
            self.display_width, self.display_height = capabilities['resolution']

        else:
            self.display_width = display_mode.w
            self.display_height = display_mode.h
            # Print the display width and height
            print(f"Display size: {self.display_width}x{self.display_height}")

        if harbourmaster.HM_TESTING:
            capabilities = harbourmaster.device_info()

            ## Uncomment one of these to pretend to be a different device. more devices in pylibs/harbourmaster/hardware.py
            pretend_device = (
                # 'rg351p'
                # 'rg552'
                # 'rg503'
                # 'rg351v'
                # 'rg353v'
                # 'ogs'
                # 'ogu'
                # 'x55'
                )

            if not pretend_device:
                pretend_device = 'pc'

            capabilities = harbourmaster.device_info(pretend_device)

            # if pretend_device in harbourmaster.HW_INFO:
            #     capabilities.update(**harbourmaster.HW_INFO[pretend_device])
            self.display_width, self.display_height = capabilities['resolution']

            print(f"Forcing size: {self.display_width}x{self.display_height}")

        if capabilities['device'] == 'default':
            device = harbourmaster.find_device_by_resolution((self.display_width, self.display_height))
            logger.debug(f"FOUND: {device}")
            if device != 'default':
                capabilities = harbourmaster.device_info(device)

        # Create the window
        self.window = sdl2.ext.Window("PortMaster", size=(self.display_width, self.display_height))
        self.window.show()

        # Create a renderer for drawing on the window
        renderer = sdl2.ext.Renderer(self.window, flags=sdl2.SDL_RENDERER_ACCELERATED)

        sdl2.SDL_SetHint(sdl2.SDL_HINT_RENDER_SCALE_QUALITY, b"2")

        super().__init__(renderer)

        self.cancellable = True

        self.init_theme()
        # self.gui.resources.add_path(harbourmaster.HM_TOOLS_DIR / "PortMaster" / "pylibs")

        theme_file = self.resources.find("theme.json")
        if theme_file is None:
            print(self.resources._paths)
            ## TODO: fix this and display a simple messagebox.
            raise RuntimeError("Unable to load theme.")

        self.text_data = {}
        self.text_data_updated = sdl2.SDL_GetTicks64() - self.TEXT_DATA_FREQ - 1
        self.changed_keys = set()
        self.formatter = StringFormatter(self.text_data)

        self.theme_data = theme_load(self, theme_file, self.get_current_theme_scheme())

        self.scenes = [
            ('root', [MainMenuScene(self)]),
            ]

        self.callback_messages = []
        self.callback_progress = None
        self.callback_amount = 0
        self.message_box_depth = 0
        self.message_box_scene = None
        self.was_cancelled = False

        self.updated = False

        device_info = harbourmaster.device_info()
        self.set_data('system.portmaster_version', PORTMASTER_VERSION)
        self.set_data('system.harbourmaster_version', harbourmaster.HARBOURMASTER_VERSION)
        self.set_data('system.cfw_name', device_info['name'])
        self.set_data('system.cfw_version', device_info['version'])
        self.set_data('system.device_name', device_info['device'])
        self.set_data('system.ip_address', get_ip_address())
        self.set_data('system.progress_text', "")
        self.set_data('system.progress_amount', "")

        self.set_data('ports_list.filters', "")
        self.set_data('ports_list.total_ports', "")
        self.set_data('ports_list.filter_ports', "")

        self.garbage_check = sdl2.SDL_GetTicks64()        

    def init_theme(self):
        ## This has to run before harbourmaster is initialised, so we gotta work it out ourself.
        theme_name = self.get_current_theme()

        self.resources.add_path(self.get_theme_dir(theme_name))

    def get_config(self):
        cfg_dir = harbourmaster.HM_TOOLS_DIR / "PortMaster"
        cfg_file = cfg_dir / "config" / "config.json"
        cfg_data = {}

        if self.hm is None:
            if cfg_file.is_file():
                with open(cfg_file, 'r') as fh:
                    cfg_data = json.load(fh)
        else:
            cfg_data = self.hm.cfg_data

        return cfg_data

    def get_current_theme(self):
        cfg_data = self.get_config()

        cfg_data.setdefault("theme", "default_theme")
        if not self.get_theme_dir(cfg_data["theme"]).is_dir():
            logger.error(f"Unable to find theme '{cfg_data['theme']}', setting to 'default_theme'")
            cfg_data["theme"] = "default_theme"

        elif not (self.get_theme_dir(cfg_data["theme"]) / "theme.json").is_file():
            logger.error(f"Unable to find theme '{cfg_data['theme']}', setting to 'default_theme'")
            cfg_data["theme"] = "default_theme"

        return cfg_data["theme"]

    def get_current_theme_scheme(self):
        cfg_data = self.get_config()
        return cfg_data.setdefault("theme-scheme", None)

    def get_theme_dir(self, theme_name):
        cfg_dir = harbourmaster.HM_TOOLS_DIR / "PortMaster"

        if theme_name in ("default_theme", "default_theme_dark"):
            return PYLIB_PATH / theme_name

        else:
            return cfg_dir / "themes" / theme_name

    def get_theme_data(self, theme_name):
        theme_file = (self.get_theme_dir(theme_name) / "theme.json")
        if not theme_file.is_file():
            logger.error(f"Unknown file {theme_file}")
            return None

        theme_data = harbourmaster.json_safe_loads(theme_file.read_text())

        if theme_data is None:
            logger.error(f"Unable to load {theme_file}")
            return None

        return theme_data

    def get_theme_info(self, theme_name):
        theme_data = self.get_theme_data(theme_name)
        if theme_data is None:
            return None

        if "#info" not in theme_data:
            print(f"Bad theme info {theme_name}")
            return None

        return theme_data["#info"]

    def get_themes_list(self):
        cfg_dir = harbourmaster.HM_TOOLS_DIR / "PortMaster"

        themes = {
            "default_theme": self.get_theme_info("default_theme"),
            }

        for theme_file in (cfg_dir / "themes").glob("*/theme.json"):
            theme_name = theme_file.parent.name
            theme_info = self.get_theme_info(theme_name)
            if theme_info is None:
                logger.error(f"THEME {theme_file} isn't a valid theme.")
                continue

            if theme_info.get("version", 0) < self.MIN_THEME_VERSION:
                logger.error(f"THEME {theme_file} does not meet the minimum version requirement: {theme_info.get('version', 0)}")
                continue

            themes[theme_name] = theme_info

        return themes

    def get_theme_schemes_list(self, theme_name=None):
        if theme_name is None:
            theme_name = self.hm.cfg_data.get("theme", "default_theme")

        theme_data = self.get_theme_data(theme_name)
        if theme_data is None:
            return []

        if "#schemes" not in theme_data:
            return []

        return [
            scheme_name
            for scheme_name in theme_data.get("#schemes", {})
            if scheme_name not in ("#base", )]

    ## Loop stuff.
    def run(self):
        try:
            while True:
                self.do_loop()

        except harbourmaster.CancelEvent:
            pass

    def do_loop(self, *, no_delay=False):
        events = self.events
        events.handle_events()

        if events.buttons['START'] and self.events.buttons['BACK']:
            events.running = False

        if not events.running:
            self.do_cancel()

        self.do_update()
        self.do_draw()

        ## TODO: fix it, 30 is approximately 30fps (1000 // 30)
        if not no_delay:
            sdl2.SDL_Delay(30)

        if (sdl2.SDL_GetTicks64() - self.garbage_check) > 1000:
            print(f"GARBAGE COUNT: {pySDL2gui.garbage.check_new()} -> {pySDL2gui.garbage.count_objects()}")
            self.garbage_check = sdl2.SDL_GetTicks64()

    def do_update(self):
        # Update tags
        time = sdl2.SDL_GetTicks64()
        if (time - self.text_data_updated) > self.TEXT_DATA_FREQ:
            self.set_data("system.time_24hr", datetime.datetime.now().strftime("%H:%M"))
            self.set_data("system.time_12hr", datetime.datetime.now().strftime("%I:%M %p"))

            disk_usage = shutil.disk_usage(str(harbourmaster.HM_PORTS_DIR))

            self.set_data("system.free_space", harbourmaster.nice_size(disk_usage.free))
            self.set_data("system.used_space", harbourmaster.nice_size(disk_usage.used))
            self.set_data("system.total_space", harbourmaster.nice_size(disk_usage.total))

            battery_file = Path("/sys/class/power_supply/battery/capacity")
            if battery_file.exists():
                self.set_data("system.battery_level", f"{int(battery_file.read_text().strip())}%")

            else:
                self.set_data("system.battery_level", _("N/A"))

            self.text_data_updated = time

        # Events get handled in reversed order.
        for scene in reversed(self.scenes[-1][1]):
            if scene.do_update(self.events):
                break

    def do_draw(self):
        ## Check for any keys changed in our template system.
        if len(self.changed_keys):
            for layer in self.scenes:
                for scene in layer[1]:
                    scene.update_data(self.changed_keys)

            self.changed_keys.clear()

        # Drawing happens in forwards order
        # if self.updated:
        self.renderer.clear()

        for scene in self.scenes[-1][1]:
            scene.do_draw()

        self.renderer.present()
        self.clean()
            # self.window.refresh()

        # self.updated = False

    def get_port_image(self, port_name):
        image = None
        if self.hm is not None:
            image = self.hm.port_images(port_name)

            if image is not None:
                image = image.get('screenshot', None)

        if image is None:
            image = self.resources.find("no-image.jpg")

        return self.images.load(image)

    def set_port_info(self, port_name, port_info):
        ## TODO: make this better :D
        if port_name is None:
            self.set_data("port_info.title", _("** NO PORT **"))
            self.set_data("port_info.description", "")
            self.set_data("port_info.instructions", "")
            self.set_data("port_info.genres", "")
            self.set_data("port_info.porter", "")
            self.set_data("port_info.ready_to_run", "")
            self.set_data("port_info.runtime", "")
            self.set_data("port_info.download_size", "")
            return

        self.set_data("port_info.title", port_info['attr']['title'])
        self.set_data("port_info.description", port_info['attr']['desc'])
        self.set_data("port_info.instructions", port_info['attr']['inst'])
        self.set_data("port_info.genres", ', '.join(port_info['attr']['genres']))
        self.set_data("port_info.porter", harbourmaster.oc_join(port_info['attr']['porter']))
        self.set_data("port_info.ready_to_run", port_info['attr']['rtr'] and _("Ready to Run") or _("Requires Files"))

        runtime = port_info['attr']['runtime']
        if runtime is not None:
            self.set_data("port_info.runtime", harbourmaster.runtime_nicename(runtime))
            if (self.hm.libs_dir / runtime).is_file():
                self.set_data("port_info.runtime_status", _("Installed"))
            else:
                self.set_data("port_info.runtime_status", _("Missing"))

        else:
            self.set_data("port_info.runtime", _("None"))
            self.set_data("port_info.runtime_status", _("N/A"))

        self.set_data("port_info.download_size", harbourmaster.nice_size(self.hm.port_download_size(port_name)))

    def set_data(self, key, value):
        if self.text_data.get(key, None) == value:
            return

        self.text_data[key] = value
        self.changed_keys.add(key)
        # logger.debug(f"{key}: {value}")

    def format_data(self, input_string, used_keys=None):
        return self.formatter.format_string(input_string, used_keys)

    def quit(self):
        # Clean up
        sdl2.ext.quit()

    ## Messagebox / Callback stuff
    def callback_update(self):
        if self.message_box_scene:
            self.message_box_scene.tags['message_text'].text = '\n'.join(self.callback_messages[-13:])

            self.do_loop(no_delay=True)

    def progress(self, message, amount, total=None, fmt=None):
        if message is None:
            self.callback_progress = None
            self.callback_amount = 0
            self.set_data("system.progress_text", "")
            self.set_data("system.progress_amount", "")

        else:
            if total is not None:
                self.callback_amount = int(amount / total * 100)
            else:
                self.callback_amount = 0

            self.set_data("system.progress_text", message)
            self.set_data("system.progress_amount", format_progress(amount, total, fmt))

        self.callback_update()

    def message(self, message):
        self.callback_messages.append(message)
        self.callback_update()

    def message_box(self, message, want_cancel=False, ok_text=None, cancel_text=None):
        """
        Display a message box
        """

        if ok_text is None:
            ok_text = _("Okay")

        if cancel_text is None:
            cancel_text = _("Cancel")

        ## This fixes a bug :D
        self.events.handle_events()

        with self.enable_cancellable(True):
            self.push_scene('message_box', MessageBoxScene(
                self, message, want_cancel=want_cancel, ok_text=ok_text, cancel_text=cancel_text))

            try:
                while True:
                    if self.events.was_pressed('A'):
                        return True

                    if want_cancel and self.events.was_pressed('B'):
                        if want_cancel:
                            return False

                        return True

                    self.do_loop()

            finally:
                self.pop_scene()

    def messages_begin(self, *, internal=False):
        """
        Show messages window.

        Deprecated, use `with gui.enable_messages():` instead
        """

        if not internal:
            logger.error("Using old messages begin/end api is deprecated.")

        if self.message_box_depth < 0:
            self.message_box_depth = 0
            self.callback_messages.clear()

        if self.message_box_depth == 0:
            self.message_box_scene = MessageWindowScene(self)
            self.push_scene('messages', self.message_box_scene)

        self.message_box_depth += 1

    def messages_end(self, *, internal=False):
        """
        Hide messages window.

        Deprecated, use `with gui.enable_messages():` instead
        """
        if not internal:
            logger.error("Using old messages begin/end api is deprecated.")

        self.message_box_depth -= 1
        if self.message_box_depth <= 0 and self.message_box_scene:
            self.message_box_depth = 0
            self.callback_messages.clear()
            self.message_box_scene = None
            self.callback_progress = None
            self.pop_scene()

    @contextlib.contextmanager
    def enable_messages(self):
        """
        Shows and hides the messages window.
        """
        try:
            self.messages_begin(internal=True)

            yield

            ## Fix a bug
            self.progress(None, None, None)

        finally:
            self.messages_end(internal=True)

    ## Scene code.
    def scene_list(self):
        return [
            scene[0]
            for scene in self.scenes]

    def all_scenes(self):
        for layer, scenes in self.scenes:
            yield from scenes

    def push_scene(self, name, scene):
        """
        Add a scene, if the name is the same as the current layer it is added to it.
        """
        if name is None:
            name = self.scenes[-1][0]

        for old_scene in self.all_scenes():
            if old_scene.active:
                print(f"DEACTIVATE {scene}")
                old_scene.scene_deactivate()

        if name == self.scenes[-1][0]:
            logger.debug(f"PUSH SCENE ADD {name}")
            self.scenes[-1][1].append(scene)
            logger.debug(f"SCENE LIST: {self.scene_list()}")

        else:
            logger.debug(f"PUSH SCENE LAYER {name}")
            self.scenes.append((name, [scene]))

            logger.debug(f"SCENE LIST: {self.scene_list()}")

        print(f"ACTIVATE {scene}")
        scene.scene_activate()

    def pop_scene(self, name=None):
        """
        Remove a single scene, or remove until we get back to scene named "name".
        """
        if name is None:
            # If name is none, just pop the most top scene.
            if len(self.scenes[-1][1]) > 1:
                logger.debug(f"POP SCENE REM {self.scenes[-1][0]}")

                self.scenes[-1][1].pop(-1)

                logger.debug(f"SCENE LIST: {self.scene_list()}")

            elif len(self.scenes) > 1:
                logger.debug(f"POP SCENE LAYER {self.scenes[-1][0]}")
                self.scenes.pop(-1)

                logger.debug(f"SCENE LIST: {self.scene_list()}")

        elif name == self.scenes[-1][0]:
            # If name is the active, scene, just remove a single scene layer from it.
            logger.debug(f"POP SCENE {name} REM {self.scenes[-1][0]}")
            if len(self.scenes[-1][1]) > 1:
                self.scenes[-1][1].pop(-1)

            logger.debug(f"SCENE LIST: {self.scene_list()}")

        else:

            while len(self.scenes) > 1:
                if self.scenes[-1][0] == name:
                    break

                logger.debug(f"POP SCENE {name} LAYER {self.scenes[-1][0]}")

                self.scenes.pop(-1)

            logger.debug(f"SCENE LIST: {self.scene_list()}")

        if not self.scenes[-1][1][-1].active:
            print(f"ACTIVATE {self.scenes[-1][1][-1]}")
            self.scenes[-1][1][-1].scene_activate()

    ## Cancelling code.
    def do_cancel(self):
        """
        Cancel if it is possible
        """
        if self.cancellable is True:
            raise harbourmaster.CancelEvent()

    @contextlib.contextmanager
    def enable_cancellable(self, cancellable=False):
        """
        Controls whether you
        """
        old_cancellable = self.cancellable
        self.cancellable = cancellable
        self.was_cancelled = False

        try:
            yield

        except requests.exceptions.ConnectionError as err:
            # self.do_popup_message(f"Connection Error: {err}")
            logger.error(f"Connection Error: {err}")
            self.was_cancelled = True

        except harbourmaster.CancelEvent:
            self.was_cancelled = True

        finally:
            self.cancellable = old_cancellable

    ## HarbourMaster Commands.
    def do_install(self, port_name):

        with self.enable_messages():
            self.message(_("Installing {port_name}").format(port_name=port_name))
            self.do_loop(no_delay=True)

            with self.enable_cancellable(True):
                self.hm.install_port(port_name)
                self.hm.load_ports()

    def do_uninstall(self, port_name):

        with self.enable_messages():
            self.message(_("Uninstalling {port_name}").format(port_name=port_name))
            self.do_loop(no_delay=True)

            with self.enable_cancellable(False):
                self.hm.uninstall_port(port_name)
                self.hm.load_ports()

    def do_update_ports(self):
        with self.enable_messages():
            with self.enable_cancellable(False):
                self.message(_('Updating all port sources:'))
                for source in self.hm.sources:
                    self.hm.sources[source].update()

                self.hm.load_ports()


@logger.catch
def main(argv):
    global LOG_FILE_HANDLE

    with make_temp_directory() as temp_dir:
        argv = argv[:]

        config = {
            'quiet': False,
            'no-check': False,
            'debug': False,
            'no-colour': False,
            'force-colour': False,
            'no-log': False,
            'help': False,
            'offline': False,
            }

        i = 1
        while i < len(argv):
            if argv[i] == '--':
                del argv[i]
                break

            if argv[i].startswith('--'):
                if argv[i][2:] in config:
                    config[argv[i][2:]] = True
                else:
                    if not config['quiet']:
                        logger.error(f"Unknown argument {argv}")

                del argv[i]
                continue

            i += 1

        if config['quiet']:
            logger.remove(0)  # For the default handler, it's actually '0'.
            logger.add(sys.stderr, level="ERROR")

        elif config['debug']:
            logger.remove(0)  # For the default handler, it's actually '0'.
            logger.add(sys.stderr, level="DEBUG")

        if config['no-log']:
            logger.remove(LOG_FILE_HANDLE)
            LOG_FILE_HANDLE = None

        if config['no-colour']:
            utility.do_color(False)

        elif config['force-colour']:
            utility.do_color(True)

        pm = PortMasterGUI()
        pm.hm = None

        with pm.enable_cancellable(False):
            hm = HarbourMaster(config, temp_dir=temp_dir, callback=pm)

        pm.hm = hm

        with pm.enable_cancellable(True):
            pm.run()

        pm.quit()


if __name__ == '__main__':
    exit(main(sys.argv))
